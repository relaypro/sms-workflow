import WebSocket from 'ws';
import * as enums from './enums';
import { LedIndex, ButtonEvent, Call, ConnectedCall, DisconnectedCall, FailedCall, NotificationEvent, Options, ReceivedCall, Relay, StartedCall, Workflow } from './types';
declare const Event: typeof enums.Event, Language: typeof enums.Language;
export * from './enums';
interface WorkflowEvents {
    [Event.START]: (event: Record<string, never>) => void;
    [Event.BUTTON]: (event: ButtonEvent) => void;
    [Event.TIMER]: (event: Record<string, never>) => void;
    [Event.NOTIFICATION]: (event: NotificationEvent) => void;
    [Event.CALL_CONNECTED]: (event: ConnectedCall) => void;
    [Event.CALL_DISCONNECTED]: (event: DisconnectedCall) => void;
    [Event.CALL_FAILED]: (event: FailedCall) => void;
    [Event.CALL_RECEIVED]: (event: ReceivedCall) => void;
    [Event.CALL_START_REQUEST]: (event: StartedCall) => void;
}
declare const createWorkflow: (fn: Workflow) => Workflow;
declare class RelayEventAdapter {
    private websocket;
    private emitter;
    constructor(websocket: WebSocket);
    on<U extends keyof WorkflowEvents>(event: U, listener: WorkflowEvents[U]): void;
    off<U extends keyof WorkflowEvents>(event: U, listener: WorkflowEvents[U]): void;
    private onClose;
    private onMessage;
    private _send;
    private _sendReceive;
    private _cast;
    private _call;
    say(text: string, lang?: enums.Language): Promise<void>;
    play(filename: string): Promise<void>;
    translate(text: string, from?: enums.Language, to?: enums.Language): Promise<string>;
    vibrate(pattern: number[]): Promise<void>;
    switchLedOn(led: LedIndex, color: string): Promise<void>;
    switchAllLedOn(color: string): Promise<void>;
    switchAllLedOff(): Promise<void>;
    rainbow(rotations?: number): Promise<void>;
    rotate(): Promise<void>;
    flash(): Promise<void>;
    breathe(): Promise<void>;
    private _getDeviceInfo;
    getDeviceName(): Promise<string>;
    getDeviceLocation(refresh: boolean): Promise<string>;
    getDeviceId(): Promise<string>;
    getDeviceAddress(refresh: boolean): Promise<string>;
    getDeviceCoordinates(refresh: boolean): Promise<number[]>;
    getDeviceLatLong(refresh: boolean): Promise<number[]>;
    getDeviceIndoorLocation(refresh: boolean): Promise<string>;
    getDeviceBattery(refresh: boolean): Promise<number>;
    private setDeviceInfo;
    setDeviceName(name: string): Promise<void>;
    setDeviceChannel(channel: string): Promise<void>;
    setChannel(name: string, target: string[]): Promise<void>;
    placeCall(call: Call): Promise<void>;
    private _buildCallIdRequestOrThrow;
    answerCall(callRequest: string | Call): Promise<void>;
    hangupCall(callRequest: string | Call): Promise<void>;
    setVar(name: string, value: string): Promise<void>;
    set(obj: Record<string, string>, value?: string): Promise<void>;
    getVar(name: string, defaultValue?: undefined): Promise<string>;
    get(names: string | string[]): Promise<string | string[]>;
    startTimer(timeout?: number): Promise<void>;
    stopTimer(): Promise<void>;
    private _sendNotification;
    broadcast(text: string, target: string[]): Promise<void>;
    notify(text: string, target: string[]): Promise<void>;
    alert(name: string, text: string, target: string[]): Promise<void>;
    cancelAlert(name: string, target: string[]): Promise<void>;
    listen(phrases?: never[], { transcribe, alt_lang, timeout }?: {
        transcribe?: boolean | undefined;
        alt_lang?: enums.Language | undefined;
        timeout?: number | undefined;
    }): Promise<Record<`text`, string> | Record<`audio`, string>>;
    createIncident(type: string): Promise<string>;
    resolveIncident(incidentId: string, reason: string): Promise<void>;
    terminate(): Promise<void>;
}
declare const initializeRelaySdk: (options?: Options) => Relay;
export { initializeRelaySdk as relay, createWorkflow, };
export type { RelayEventAdapter, Event, Workflow, Relay, Language, Options };
