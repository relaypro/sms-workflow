"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createWorkflow = exports.relay = void 0;
const tslib_1 = require("tslib");
const ws_1 = tslib_1.__importDefault(require("ws"));
const events_1 = tslib_1.__importDefault(require("events"));
const enums = tslib_1.__importStar(require("./enums"));
const utils_1 = require("./utils");
const constants_1 = require("./constants");
const { Event, Language, DeviceInfoQuery, DeviceInfoField, Notification, } = enums;
tslib_1.__exportStar(require("./enums"), exports);
const createWorkflow = (fn) => fn;
exports.createWorkflow = createWorkflow;
const WORKFLOW_EVENT_REGEX = /^wf_api_(\w+)_event$/;
class RelayEventAdapter {
    constructor(websocket) {
        Object.defineProperty(this, "websocket", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        Object.defineProperty(this, "emitter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        console.log(`creating event adapter`);
        this.emitter = new events_1.default.EventEmitter();
        this.websocket = websocket;
        this.websocket.on(`close`, this.onClose.bind(this));
        this.websocket.on(`message`, this.onMessage.bind(this));
    }
    on(event, listener) {
        this.emitter?.on(event, listener);
    }
    off(event, listener) {
        this.emitter?.off(event, listener);
    }
    async onClose() {
        this.websocket = null;
    }
    onMessage(msg) {
        const message = utils_1.safeParse(msg);
        if (this.emitter && message?._type && !message?._id) { // not interested in response events (marked by correlation id)
            const eventNameParts = message._type.match(WORKFLOW_EVENT_REGEX);
            if (eventNameParts?.[1]) {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const { _type, ...args } = message;
                this.emitter.emit(eventNameParts?.[1], args);
            }
            else {
                console.log(`Unknown message =>`, message);
            }
        }
    }
    /*
    private async stop(): Promise<void> {
      console.log(`stopping event adapter`)
      if (this.websocket) {
        console.log(`terminating event adapter websocket`)
        this.websocket.terminate()
      }
    }
    */
    async _send(type, payload = {}, id) {
        return new Promise((resolve, reject) => {
            if (!this.websocket) {
                reject(`websocket-not-connected`);
                return;
            }
            const message = {
                _id: id ?? utils_1.makeId(),
                _type: `wf_api_${type}_request`,
                ...payload,
            };
            const messageStr = JSON.stringify(message);
            this.websocket.send(messageStr, (err) => {
                if (err) {
                    reject(`failed-to-send`);
                }
                else {
                    resolve();
                }
            });
        });
    }
    async _sendReceive(type, payload = {}, timeout = constants_1.TIMEOUT) {
        const id = utils_1.makeId();
        await this._send(type, payload, id);
        return new Promise((resolve, reject) => {
            const timeoutHandle = setTimeout(() => {
                this.websocket?.off?.(`message`, responseListener);
                reject(`failed-to-receive-response-timeout`);
            }, timeout);
            const responseListener = (msg) => {
                clearTimeout(timeoutHandle);
                const event = utils_1.safeParse(msg);
                if (event) {
                    const { _id, _type, ...params } = event;
                    if (_id === id) { // interested here in response events (marked by correlation id)
                        // stop listening as soon as we have a correlated response
                        this.websocket?.off(`message`, responseListener);
                        if (_type === `wf_api_${type}_response`) {
                            resolve(Object.keys(params).length > 0 ? params : undefined);
                        }
                        else if (_type === `wf_api_error_response`) {
                            reject(event?.error);
                        }
                        else {
                            console.log(`Unknown response`, event);
                            reject(new Error(`Unknown response`));
                        }
                    }
                }
            };
            // start listening to websocket messages for correlated response
            this.websocket?.on(`message`, responseListener);
        });
    }
    async _cast(type, payload = {}, timeout = constants_1.TIMEOUT) {
        await this._sendReceive(type, payload, timeout);
    }
    async _call(type, payload = {}, timeout = constants_1.TIMEOUT) {
        return (await this._sendReceive(type, payload, timeout));
    }
    async say(text, lang = Language.ENGLISH) {
        await this._cast(`say`, { text, lang });
    }
    async play(filename) {
        await this._cast(`play`, { filename });
    }
    async translate(text, from = Language.ENGLISH, to = Language.SPANISH) {
        const { text: translatedText } = (await this._call(`translate`, { text, from_lang: from, to_lang: to }));
        return translatedText;
    }
    async vibrate(pattern) {
        await this._cast(`vibrate`, { pattern });
    }
    async switchLedOn(led, color) {
        await this._cast(`set_led`, { effect: `static`, args: { colors: { [`${led}`]: color } } });
    }
    async switchAllLedOn(color) {
        await this._cast(`set_led`, { effect: `static`, args: { colors: { ring: color } } });
    }
    async switchAllLedOff() {
        await this._cast(`set_led`, { effect: `off`, args: {} });
    }
    async rainbow(rotations = -1) {
        await this._cast(`set_led`, { effect: `rainbow`, args: { rotations } });
    }
    async rotate() {
        await this._cast(`set_led`, { effect: `rotate`, args: { rotations: -1, colors: { [`1`]: `FFFFFF` } } });
    }
    async flash() {
        await this._cast(`set_led`, { effect: `flash`, args: { count: -1, colors: { ring: `0000FF` } } });
    }
    async breathe() {
        await this._cast(`set_led`, { effect: `breathe`, args: { count: -1, colors: { ring: `0000FF` } } });
    }
    async _getDeviceInfo(query, refresh = false) {
        const response = await this._call(`get_device_info`, { query, refresh }, refresh ? constants_1.REFRESH_TIMEOUT : constants_1.TIMEOUT);
        return response[query];
    }
    async getDeviceName() {
        return await this._getDeviceInfo(DeviceInfoQuery.NAME);
    }
    async getDeviceLocation(refresh) {
        return await this._getDeviceInfo(DeviceInfoQuery.ADDRESS, refresh);
    }
    async getDeviceId() {
        return await this._getDeviceInfo(DeviceInfoQuery.ID);
    }
    async getDeviceAddress(refresh) {
        return await this.getDeviceLocation(refresh);
    }
    async getDeviceCoordinates(refresh) {
        return await this._getDeviceInfo(DeviceInfoQuery.COORDINATES, refresh);
    }
    async getDeviceLatLong(refresh) {
        return await this.getDeviceCoordinates(refresh);
    }
    async getDeviceIndoorLocation(refresh) {
        return await this._getDeviceInfo(DeviceInfoQuery.INDOOR_LOCATION, refresh);
    }
    async getDeviceBattery(refresh) {
        return await this._getDeviceInfo(DeviceInfoQuery.BATTERY, refresh);
    }
    async setDeviceInfo(field, value) {
        await this._cast(`set_device_info`, { field, value });
    }
    async setDeviceName(name) {
        await this.setDeviceInfo(DeviceInfoField.LABEL, name);
    }
    async setDeviceChannel(channel) {
        await this.setDeviceInfo(DeviceInfoField.CHANNEL, channel);
    }
    async setChannel(name, target) {
        await this._cast(`set_channel`, { channel_name: name, target });
    }
    async placeCall(call) {
        await this._call(`call`, call);
    }
    _buildCallIdRequestOrThrow(arg) {
        if (typeof arg === `string`) {
            return { call_id: arg };
        }
        else if (typeof arg === `object`) {
            if (typeof arg.call_id === `string`) {
                return { call_id: arg.call_id };
            }
            else {
                throw new Error(`missing required parameter`);
            }
        }
        else {
            throw new Error(`invalid argument type`);
        }
    }
    async answerCall(callRequest) {
        await this._call(`answer`, this._buildCallIdRequestOrThrow(callRequest));
    }
    async hangupCall(callRequest) {
        await this._call(`hangup`, this._buildCallIdRequestOrThrow(callRequest));
    }
    async setVar(name, value) {
        await this._cast(`set_var`, { name, value });
    }
    async set(obj, value) {
        if (typeof obj === `object`) {
            await Promise.all(Object.entries(obj)
                .map(([name, value]) => this.setVar(name, value)));
        }
        else if (value !== undefined) {
            await this.setVar(obj, value);
        }
    }
    async getVar(name, defaultValue = undefined) {
        const { value } = (await this._call(`get_var`, { name }) ?? defaultValue);
        return value;
    }
    async get(names) {
        if (Array.isArray(names)) {
            return Promise.all(names.map(name => this.getVar(name)));
        }
        else {
            return this.getVar(names);
        }
    }
    async startTimer(timeout = 60) {
        await this._cast(`start_timer`, { timeout });
    }
    async stopTimer() {
        await this._cast(`stop_timer`);
    }
    async _sendNotification(type, text, target, name) {
        await this._cast(`notification`, { type, name, text, target });
    }
    async broadcast(text, target) {
        await this._sendNotification(Notification.BROADCAST, text, target);
    }
    async notify(text, target) {
        await this._sendNotification(Notification.NOTIFY, text, target);
    }
    async alert(name, text, target) {
        await this._sendNotification(Notification.ALERT, text, target, name);
    }
    async cancelAlert(name, target) {
        await this._sendNotification(Notification.CANCEL, undefined, target, name);
    }
    async listen(phrases = [], { transcribe = true, alt_lang = Language.ENGLISH, timeout = 60 } = {}) {
        const response = await this._call(`listen`, { transcribe, phrases, timeout, alt_lang }, timeout * 1000);
        if (transcribe) {
            return { text: response.text };
        }
        else {
            return { audio: response.audio };
        }
    }
    async createIncident(type) {
        const { incident_id } = await this._call(`create_incident`, { type });
        return incident_id;
    }
    async resolveIncident(incidentId, reason) {
        await this._cast(`resolve_incident`, { incident_id: incidentId, reason });
    }
    async terminate() {
        await this._send(`terminate`);
    }
}
const DEFAULT_WORKFLOW = `__default_relay_workflow__`;
let workflows = null;
let instances = null;
let server = null;
const initializeRelaySdk = (options = {}) => {
    if (workflows) {
        throw new Error(`Relay SDK already initialized`);
    }
    else {
        workflows = new Map();
        instances = new Map();
        const serverOptions = options.server ? { server: options.server } : { port: constants_1.PORT };
        console.log(serverOptions)
        server = new ws_1.default.Server(serverOptions, () => {
            console.log(`Relay SDK WebSocket Server listening => ${constants_1.PORT}`);
        });
        server.shouldHandle = (request) => {
            console.info(`WebSocket request =>`, request.url);
            if (request.url) {
                const shouldEnforceStrictPaths = (options.STRICT_PATH ?? constants_1.STRICT_PATH) === `1`;
                const path = request.url.slice(1);
                const hasDefaultWorkflow = workflows?.has(DEFAULT_WORKFLOW);
                const hasNamedWorkflow = workflows?.has(path);
                return (shouldEnforceStrictPaths ? hasNamedWorkflow : hasDefaultWorkflow) ?? false;
            }
            else {
                return false;
            }
        };
        server.on(`connection`, (websocket, request) => {
            if (request.url && workflows) {
                const path = request.url.slice(1);
                const workflowName = workflows.has(path) ? path : DEFAULT_WORKFLOW;
                const workflow = workflows.get(workflowName);
                if (workflow) {
                    websocket.connectionId = `${workflowName}-${utils_1.makeId()}`;
                    websocket.isAlive = true;
                    websocket.on(`pong`, () => {
                        websocket.isAlive = true;
                    });
                    websocket.on(`close`, ( /*code, reason*/) => {
                        console.info(`Workflow closed =>`, websocket.connectionId);
                        instances?.delete(websocket.connectionId);
                    });
                    const adapter = new RelayEventAdapter(websocket);
                    workflow(adapter);
                    instances?.set(websocket.connectionId, adapter);
                    console.info(`Workflow connection =>`, websocket.connectionId);
                }
                else {
                    console.info(`Workflow not found; terminating websocket =>`, websocket.connectionId);
                    websocket.terminate();
                }
            }
        });
        server.on(`error`, err => {
            console.error(err);
        });
        setInterval(() => {
            server?.clients.forEach((websocket) => {
                const _websocket = websocket;
                if (_websocket.isAlive === false) {
                    return websocket.terminate();
                }
                _websocket.isAlive = false;
                websocket.ping(utils_1.noop);
            });
        }, constants_1.HEARTBEAT);
        return {
            workflow: (path, workflow) => {
                if (workflows) {
                    if ((typeof path === `function`)) {
                        console.info(`Default workflow set`);
                        workflows.set(DEFAULT_WORKFLOW, path);
                    }
                    else if (typeof path === `string`) {
                        const strippedPath = path.replace(/^\/+/, ``);
                        workflows.set(strippedPath, workflow);
                    }
                    else {
                        throw new Error(`First argument for workflow must either be a string or a function`);
                    }
                }
                else {
                    console.error(`workflows is not initialized`);
                }
            }
        };
    }
};
exports.relay = initializeRelaySdk;
